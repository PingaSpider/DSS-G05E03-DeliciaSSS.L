document.addEventListener("DOMContentLoaded", () => {
    console.log("‚úÖ Script malicioso cargado correctamente.");

    // Referencias a elementos del DOM
    const formDesencriptar = document.getElementById("formDesencriptar");
    const listaRegistros = document.getElementById("listaRegistros");
    const visorLog = document.getElementById("logMalicioso");
    const visorJson = document.getElementById("jsonDescifrado");
    const modoSelector = document.getElementById("modo");

    // Elementos para cambiar entre archivo y localStorage
    const divSeleccionarArchivo = document.getElementById("seleccionarArchivo");
    const divMostrarLocalStorage = document.getElementById("mostrarLocalStorage");
    const radios = document.querySelectorAll("input[name='fuenteArchivo']");

    // Variables globales
    let registroElegido = null;
    let nombreRegistroElegido = null;
    let metadatosRegistro = null;
    let contenidoCifrado = null;

    // Configuraci√≥n de ataques
    const contrasenasComunes = [
        "password", "123456", "qwerty", "123456789", "12345678", 
        "12345", "1234567", "1234567890", "abc123", "111111", 
        "123123", "admin", "letmein", "welcome", "monkey",
        "1q2w3e", "1234", "qwerty123", "dragon", "baseball"
    ];

    // Inicializaci√≥n
    function init() {
        // Configurar eventos para cambiar entre sistemas de archivo y localStorage
        radios.forEach(radio => {
            radio.addEventListener("change", actualizarVisibilidad);
        });

        // Evento para el formulario de desencriptar
        if (formDesencriptar) {
            formDesencriptar.addEventListener("submit", async function(e) {
                e.preventDefault();
                limpiarVisor();
                
                try {
                    await cargarRegistro();
                    
                    if (!registroElegido) {
                        log("‚ö†Ô∏è No se seleccion√≥ ning√∫n registro o archivo.");
                        return;
                    }
                    
                    iniciarAtaque();
                } catch (error) {
                    log(`‚ùå Error al iniciar el ataque: ${error.message}`);
                    console.error("Error detallado:", error);
                }
            });
        }

        // Inicializar la visibilidad seg√∫n la opci√≥n seleccionada
        actualizarVisibilidad();
    }

    // Gesti√≥n de visibilidad seg√∫n la fuente seleccionada
    function actualizarVisibilidad() {
        if (document.getElementById("opcionArchivo").checked) {
            divSeleccionarArchivo.style.display = "block";
            divMostrarLocalStorage.style.display = "none";
        } else {
            divSeleccionarArchivo.style.display = "none";
            divMostrarLocalStorage.style.display = "block";
            cargarListaRegistros();
        }
    }

    // Cargar lista de registros desde localStorage
    function cargarListaRegistros() {
        listaRegistros.innerHTML = "";
        listaRegistros.style.display = "block";
        
        // Intentar cargar tanto registrosEncriptados como RegistrosJsonZipEnc
        const registrosTipos = [
            { nombre: "registrosEncriptados", titulo: "Registros del Sistema" },
            { nombre: "clavesRegistros", titulo: "Claves de Registros" }
        ];
        
        let hayRegistros = false;
        
        for (const tipoRegistro of registrosTipos) {
            const registros = JSON.parse(localStorage.getItem(tipoRegistro.nombre)) || [];
            
            if (registros.length > 0) {
                hayRegistros = true;
                const seccion = document.createElement("div");
                seccion.classList.add("seccion-registros");
                
                const titulo = document.createElement("h4");
                titulo.textContent = tipoRegistro.titulo;
                seccion.appendChild(titulo);
                
                registros.forEach(reg => {
                    const contenedor = document.createElement("div");
                    contenedor.classList.add("registro-container");
                    
                    // Nombre del registro (puede variar seg√∫n el tipo)
                    const nombreReg = reg.nombreRegistro || reg.nombre || "Registro sin nombre";
                    
                    // Bot√≥n de selecci√≥n
                    const boton = document.createElement("button");
                    boton.classList.add("button", "registro-btn");
                    boton.textContent = nombreReg;
                    boton.title = "Seleccionar Registro";
                    boton.dataset.tipo = tipoRegistro.nombre;
                    boton.addEventListener("click", function() {
                        seleccionarRegistro(nombreReg, tipoRegistro.nombre, reg);
                    });
                    
                    contenedor.appendChild(boton);
                    seccion.appendChild(contenedor);
                });
                
                listaRegistros.appendChild(seccion);
            }
        }
        
        if (!hayRegistros) {
            listaRegistros.innerHTML = "<p>No hay registros cifrados en LocalStorage.</p>";
        }
    }

    // Seleccionar un registro espec√≠fico
    function seleccionarRegistro(nombre, tipo, registro) {
        nombreRegistroElegido = nombre;
        registroElegido = registro;
        
        log(`üìÇ Registro seleccionado: ${nombre} (${tipo})`);
        
        // Resaltar el bot√≥n seleccionado
        document.querySelectorAll(".registro-btn").forEach(btn => {
            btn.classList.remove("seleccionado");
        });
        
        event.target.classList.add("seleccionado");
    }

    // Cargar el registro seleccionado (archivo o localStorage)
    async function cargarRegistro() {
        if (document.getElementById("opcionArchivo").checked) {
            await cargarDesdeArchivo();
        } else {
            // Ya tenemos el registro elegido desde seleccionarRegistro
            if (!registroElegido) {
                log("‚ö†Ô∏è No se ha seleccionado ning√∫n registro del localStorage.");
            }
        }
    }

    // Cargar desde archivo
    async function cargarDesdeArchivo() {
        const inputArchivo = document.getElementById("archivoEncriptado");
        
        if (!inputArchivo || inputArchivo.files.length === 0) {
            log("‚ö†Ô∏è No se seleccion√≥ ning√∫n archivo.");
            return null;
        }
        
        const archivo = inputArchivo.files[0];
        nombreRegistroElegido = archivo.name.split(".")[0];
        
        log(`üìÇ Archivo seleccionado: ${nombreRegistroElegido} (${archivo.size} bytes)`);
        
        try {
            const contenidoArchivo = await leerArchivo(archivo);
            
            // Verificar si es un archivo ZIP.ENC
            if (archivo.name.endsWith('.zip.enc')) {
                await procesarArchivoZipEnc(contenidoArchivo);
            } 
            // Otros tipos de archivos
            else {
                log("‚ö†Ô∏è Formato de archivo no reconocido. Se esperaba .zip.enc");
                return null;
            }
        } catch (error) {
            log(`‚ùå Error al leer el archivo: ${error.message}`);
            console.error("Error detallado:", error);
        }
    }

    // Leer contenido del archivo como ArrayBuffer
    function leerArchivo(archivo) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            
            reader.onload = (event) => {
                resolve(event.target.result);
            };
            
            reader.onerror = (error) => {
                reject(error);
            };
            
            reader.readAsArrayBuffer(archivo);
        });
    }

    // Procesar archivo ZIP.ENC
    async function procesarArchivoZipEnc(contenidoArchivo) {
        log("üîç Procesando archivo ZIP encriptado...");
        
        try {
            // Descomprimir el ZIP para obtener los archivos internos
            const zip = new JSZip();
            const zipContent = await zip.loadAsync(contenidoArchivo);
            
            // Verificar si contiene los archivos esperados (datos.enc y metadata.json)
            if (zipContent.files['datos.enc'] && zipContent.files['metadata.json']) {
                // Extraer los datos cifrados
                contenidoCifrado = await zipContent.files['datos.enc'].async('uint8array');
                
                // Extraer y parsear los metadatos
                const metadataText = await zipContent.files['metadata.json'].async('text');
                metadatosRegistro = JSON.parse(metadataText);
                
                log(`‚úÖ Archivo procesado correctamente. Nombre: ${metadatosRegistro.nombreRegistro}`);
                
                // Preparar el objeto para el descifrado
                registroElegido = {
                    datosCifrados: Array.from(contenidoCifrado),
                    iv: metadatosRegistro.iv,
                    salt: metadatosRegistro.salt,
                    nombreRegistro: metadatosRegistro.nombreRegistro
                };
                
                nombreRegistroElegido = metadatosRegistro.nombreRegistro;
            } else {
                log("‚ùå El archivo ZIP no contiene los archivos esperados (datos.enc y metadata.json)");
            }
        } catch (error) {
            log(`‚ùå Error al procesar el archivo ZIP: ${error.message}`);
            console.error("Error detallado:", error);
        }
    }

    // Iniciar el ataque seg√∫n el modo seleccionado
    async function iniciarAtaque() {
        const modo = modoSelector.value;
        
        log(`‚ö° Iniciando ataque en modo: ${modo}`);
        
        // Crear instancia de seguridad
        const seguridad = new SeguridadRegistros();
        
        // Ejecutar ataque seg√∫n el modo seleccionado
        switch (modo) {
            case "basico":
                await ejecutarAtaqueBasico(seguridad);
                break;
            case "claveMaestra":
                await ejecutarAtaqueClaveMaestra(seguridad);
                break;
            case "avanzado":
                await ejecutarAtaqueAvanzado(seguridad);
                break;
            default:
                log("‚ö†Ô∏è Modo de ataque no reconocido.");
        }
    }

    // Ataque b√°sico: probar contrase√±as comunes
    async function ejecutarAtaqueBasico(seguridad) {
        log("üîì Ejecutando ataque b√°sico (contrase√±as comunes)...");
        
        let intentos = 0;
        
        for (const password of contrasenasComunes) {
            intentos++;
            log(`üîë Intento ${intentos}: Probando contrase√±a "${password}"`);
            
            try {
                const resultado = await seguridad.descifrarRegistro(registroElegido, password);
                
                if (resultado) {
                    log(`‚úÖ √âXITO: Contrase√±a encontrada: "${password}"`);
                    mostrarResultado(resultado, password);
                    return true;
                }
            } catch (error) {
                // Solo registrar el error en la consola para debug
                console.log(`Contrase√±a incorrecta: ${password}`);
            }
            
            // A√±adir peque√±o retraso entre intentos para no bloquear la UI
            await new Promise(resolve => setTimeout(resolve, 200));
        }
        
        log(`‚ùå Ataque b√°sico fallido. Se probaron ${intentos} contrase√±as comunes.`);
        return false;
    }

    // Ataque usando la clave maestra del sessionStorage
    async function ejecutarAtaqueClaveMaestra(seguridad) {
        log("üîê Ejecutando ataque de clave maestra...");
        
        const claveMaestra = sessionStorage.getItem("claveMaestraTemporal");
        
        if (!claveMaestra) {
            log("‚ö†Ô∏è No se encontr√≥ ninguna clave maestra en el sessionStorage.");
            return false;
        }
        
        log(`üîë Clave maestra encontrada en sessionStorage: "${maskPassword(claveMaestra)}"`);
        
        // Crear nueva instancia con la clave maestra encontrada
        const seguridadConClave = new SeguridadRegistros(claveMaestra);
        
        // Buscar la clave del registro en localStorage
        const clavesRegistros = JSON.parse(localStorage.getItem('clavesRegistros')) || [];
        const claveRegistroInfo = clavesRegistros.find(cr => cr.nombreRegistro === nombreRegistroElegido);
        
        if (!claveRegistroInfo) {
            log(`‚ö†Ô∏è No se encontr√≥ informaci√≥n de clave para el registro: ${nombreRegistroElegido}`);
            return false;
        }
        
        try {
            log("üîì Intentando descifrar la clave del registro con la clave maestra...");
            
            // Descifrar la contrase√±a del registro usando la clave maestra
            const password = await seguridadConClave.descifrarConClaveMaestra(claveRegistroInfo.clave);
            
            log("üîë Contrase√±a del registro descifrada correctamente.");
            
            // Usar la contrase√±a para descifrar el registro
            const resultado = await seguridadConClave.descifrarRegistro(registroElegido, password);
            
            log("‚úÖ √âXITO: Registro descifrado correctamente mediante clave maestra.");
            mostrarResultado(resultado, password);
            return true;
        } catch (error) {
            log(`‚ùå Error al descifrar con clave maestra: ${error.message}`);
            console.error("Error detallado:", error);
            return false;
        }
    }

    // Ataque avanzado: combinaci√≥n de clave maestra y fuerza bruta
    async function ejecutarAtaqueAvanzado(seguridad) {
        log("‚ö° Ejecutando ataque avanzado...");
        
        // Primero intentar con clave maestra
        const exito = await ejecutarAtaqueClaveMaestra(seguridad);
        
        if (exito) {
            return true;
        }
        
        log("‚Ü™Ô∏è Ataque con clave maestra fall√≥, pasando a ataque de fuerza bruta avanzado...");
        
        // Si no funciona, intentar fuerza bruta con un conjunto m√°s amplio
        // Generar combinaciones de caracteres m√°s complejas
        return await ejecutarFuerzaBrutaAvanzada(seguridad);
    }

    // Fuerza bruta avanzada para el ataque avanzado
    async function ejecutarFuerzaBrutaAvanzada(seguridad) {
        const caracteresBasicos = "abcdefghijklmnopqrstuvwxyz0123456789";
        const caracteresAvanzados = caracteresBasicos + "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()_+";
        
        // Probar primero con contrase√±as comunes modificadas
        const contrasenasMod = generarVariacionesContrasenas(contrasenasComunes);
        
        log(`üîç Probando ${contrasenasMod.length} variaciones de contrase√±as comunes...`);
        
        for (const password of contrasenasMod) {
            try {
                const resultado = await seguridad.descifrarRegistro(registroElegido, password);
                
                if (resultado) {
                    log(`‚úÖ √âXITO: Contrase√±a encontrada: "${password}"`);
                    mostrarResultado(resultado, password);
                    return true;
                }
            } catch (error) {
                // Ignorar errores
            }
            
            // A√±adir peque√±o retraso entre intentos
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        log("‚Ü™Ô∏è No se encontr√≥ la contrase√±a en las variaciones comunes.");
        
        // Generar contrase√±as aleatoriamente (limitado a un n√∫mero razonable de intentos)
        const maxIntentos = 1000;
        log(`üîÑ Iniciando fuerza bruta aleatoria (m√°ximo ${maxIntentos} intentos)...`);
        
        for (let i = 0; i < maxIntentos; i++) {
            // Alternar entre longitudes de 4 a 8 caracteres
            const longitud = 4 + Math.floor(Math.random() * 5);
            const password = generarClaveAleatoria(longitud, caracteresAvanzados);
            
            if (i % 100 === 0) {
                log(`üîÑ Progreso: ${i}/${maxIntentos} intentos...`);
            }
            
            try {
                const resultado = await seguridad.descifrarRegistro(registroElegido, password);
                
                if (resultado) {
                    log(`‚úÖ √âXITO: Contrase√±a encontrada: "${password}" (intento ${i+1})`);
                    mostrarResultado(resultado, password);
                    return true;
                }
            } catch (error) {
                // Ignorar errores
            }
        }
        
        log(`‚ùå Ataque avanzado fallido despu√©s de ${maxIntentos} intentos.`);
        return false;
    }

    // Generar variaciones de contrase√±as comunes
    function generarVariacionesContrasenas(contrasenas) {
        const variaciones = [];
        
        // Agregar las contrase√±as originales
        variaciones.push(...contrasenas);
        
        // Agregar variaciones con may√∫sculas al inicio
        contrasenas.forEach(pass => {
            if (pass.length > 0) {
                variaciones.push(pass[0].toUpperCase() + pass.slice(1));
            }
        });
        
        // Agregar n√∫meros al final
        contrasenas.forEach(pass => {
            for (let i = 0; i < 10; i++) {
                variaciones.push(pass + i);
            }
        });
        
        // Agregar s√≠mbolos comunes al final
        const simbolos = ['!', '@', '#', '$', '%', '&', '*'];
        contrasenas.forEach(pass => {
            simbolos.forEach(simbolo => {
                variaciones.push(pass + simbolo);
            });
        });
        
        return variaciones;
    }

    // Generar clave aleatoria para fuerza bruta
    function generarClaveAleatoria(longitud, caracteres) {
        let clave = "";
        for (let i = 0; i < longitud; i++) {
            clave += caracteres.charAt(Math.floor(Math.random() * caracteres.length));
        }
        return clave;
    }

    // Mostrar resultado del descifrado
    function mostrarResultado(resultado, password) {
        log(`üîê Contrase√±a utilizada: "${password}"`);
        log("üìã Datos descifrados correctamente:");
        
        visorJson.textContent = JSON.stringify(resultado, null, 2);
        
        // Guardar en localStorage para fines educativos
        guardarResultado(resultado, password);
    }

    // Guardar resultado del ataque
    function guardarResultado(resultado, password) {
        // Crear una copia del resultado y agregar la contrase√±a usada
        const resultadoConPass = { ...resultado, _passwordUsada: password };
        
        // Guardar en localStorage el registro descifrado
        const resultadosGuardados = JSON.parse(localStorage.getItem('resultadosAtaques') || '[]');
        resultadosGuardados.push(resultadoConPass);
        localStorage.setItem('resultadosAtaques', JSON.stringify(resultadosGuardados));
        
        log("üíæ Resultado guardado en localStorage['resultadosAtaques']");
    }

    // Ocultar parte de la contrase√±a para mostrarla en logs
    function maskPassword(password) {
        if (!password || password.length <= 3) return "***";
        return password.substring(0, 2) + "*".repeat(password.length - 3) + password.substring(password.length - 1);
    }

    // Funciones de logging
    function log(mensaje) {
        const timestamp = new Date().toLocaleTimeString();
        visorLog.textContent += `[${timestamp}] ${mensaje}\n`;
        visorLog.scrollTop = visorLog.scrollHeight; // Auto-scroll
        console.log(mensaje);
    }

    function limpiarVisor() {
        visorLog.textContent = "";
        visorJson.textContent = "";
    }

    // Iniciar script
    init();
});
document.addEventListener("DOMContentLoaded", () => {
    console.log("‚úÖ Script malicioso cargado correctamente.");

    // Referencias a elementos del DOM
    const formDesencriptar = document.getElementById("formDesencriptar");
    const listaRegistros = document.getElementById("listaRegistros");
    const visorLog = document.getElementById("logMalicioso");
    const visorJson = document.getElementById("jsonDescifrado");
    const modoSelector = document.getElementById("modo");

    // Elementos para cambiar entre archivo y localStorage
    const divSeleccionarArchivo = document.getElementById("seleccionarArchivo");
    const divMostrarLocalStorage = document.getElementById("mostrarLocalStorage");
    const radios = document.querySelectorAll("input[name='fuenteArchivo']");

    // Variables globales
    let registroElegido = null;
    let nombreRegistroElegido = null;
    let metadatosRegistro = null;
    let contenidoCifrado = null;

    // Configuraci√≥n de ataques
    const contrasenasComunes = [
        "password", "123456", "qwerty", "123456789", "12345678", 
        "12345", "1234567", "1234567890", "abc123", "111111", 
        "123123", "admin", "letmein", "welcome", "monkey",
        "1q2w3e", "1234", "qwerty123", "dragon", "baseball"
    ];

    // Inicializaci√≥n
    function init() {
        // Configurar eventos para cambiar entre sistemas de archivo y localStorage
        radios.forEach(radio => {
            radio.addEventListener("change", actualizarVisibilidad);
        });

        // Evento para el formulario de desencriptar
        if (formDesencriptar) {
            formDesencriptar.addEventListener("submit", async function(e) {
                e.preventDefault();
                limpiarVisor();
                
                try {
                    await cargarRegistro();
                    
                    if (!registroElegido) {
                        log("‚ö†Ô∏è No se seleccion√≥ ning√∫n registro o archivo.");
                        return;
                    }
                    
                    iniciarAtaque();
                } catch (error) {
                    log(`‚ùå Error al iniciar el ataque: ${error.message}`);
                    console.error("Error detallado:", error);
                }
            });
        }

        // Inicializar la visibilidad seg√∫n la opci√≥n seleccionada
        actualizarVisibilidad();
    }

    // Gesti√≥n de visibilidad seg√∫n la fuente seleccionada
    function actualizarVisibilidad() {
        if (document.getElementById("opcionArchivo").checked) {
            divSeleccionarArchivo.style.display = "block";
            divMostrarLocalStorage.style.display = "none";
        } else {
            divSeleccionarArchivo.style.display = "none";
            divMostrarLocalStorage.style.display = "block";
            cargarListaRegistros();
        }
    }

    // Cargar lista de registros desde localStorage
    function cargarListaRegistros() {
        listaRegistros.innerHTML = "";
        listaRegistros.style.display = "block";
        
        // Intentar cargar tanto registrosEncriptados como RegistrosJsonZipEnc
        const registrosTipos = [
            { nombre: "registrosEncriptados", titulo: "Registros del Sistema" },
            { nombre: "clavesRegistros", titulo: "Claves de Registros" }
        ];
        
        let hayRegistros = false;
        
        for (const tipoRegistro of registrosTipos) {
            const registros = JSON.parse(localStorage.getItem(tipoRegistro.nombre)) || [];
            
            if (registros.length > 0) {
                hayRegistros = true;
                const seccion = document.createElement("div");
                seccion.classList.add("seccion-registros");
                
                const titulo = document.createElement("h4");
                titulo.textContent = tipoRegistro.titulo;
                seccion.appendChild(titulo);
                
                registros.forEach(reg => {
                    const contenedor = document.createElement("div");
                    contenedor.classList.add("registro-container");
                    
                    // Nombre del registro (puede variar seg√∫n el tipo)
                    const nombreReg = reg.nombreRegistro || reg.nombre || "Registro sin nombre";
                    
                    // Bot√≥n de selecci√≥n
                    const boton = document.createElement("button");
                    boton.classList.add("button", "registro-btn");
                    boton.textContent = nombreReg;
                    boton.title = "Seleccionar Registro";
                    boton.dataset.tipo = tipoRegistro.nombre;
                    boton.addEventListener("click", function() {
                        seleccionarRegistro(nombreReg, tipoRegistro.nombre, reg);
                    });
                    
                    contenedor.appendChild(boton);
                    seccion.appendChild(contenedor);
                });
                
                listaRegistros.appendChild(seccion);
            }
        }
        
        if (!hayRegistros) {
            listaRegistros.innerHTML = "<p>No hay registros cifrados en LocalStorage.</p>";
        }
    }

    // Seleccionar un registro espec√≠fico
    function seleccionarRegistro(nombre, tipo, registro) {
        nombreRegistroElegido = nombre;
        registroElegido = registro;
        
        log(`üìÇ Registro seleccionado: ${nombre} (${tipo})`);
        
        // Resaltar el bot√≥n seleccionado
        document.querySelectorAll(".registro-btn").forEach(btn => {
            btn.classList.remove("seleccionado");
        });
        
        event.target.classList.add("seleccionado");
    }

    // Cargar el registro seleccionado (archivo o localStorage)
    async function cargarRegistro() {
        if (document.getElementById("opcionArchivo").checked) {
            await cargarDesdeArchivo();
        } else {
            // Ya tenemos el registro elegido desde seleccionarRegistro
            if (!registroElegido) {
                log("‚ö†Ô∏è No se ha seleccionado ning√∫n registro del localStorage.");
            }
        }
    }

    // Cargar desde archivo
    async function cargarDesdeArchivo() {
        const inputArchivo = document.getElementById("archivoEncriptado");
        
        if (!inputArchivo || inputArchivo.files.length === 0) {
            log("‚ö†Ô∏è No se seleccion√≥ ning√∫n archivo.");
            return null;
        }
        
        const archivo = inputArchivo.files[0];
        nombreRegistroElegido = archivo.name.split(".")[0];
        
        log(`üìÇ Archivo seleccionado: ${nombreRegistroElegido} (${archivo.size} bytes)`);
        
        try {
            const contenidoArchivo = await leerArchivo(archivo);
            
            // Verificar si es un archivo ZIP.ENC (aceptando cualquier variante del nombre)
            // Usamos una expresi√≥n regular para detectar .zip y .enc en cualquier parte del nombre
            if (archivo.name.match(/\.zip.*\.enc$/i) || archivo.name.toLowerCase().includes('.zip.enc')) {
                log("‚úÖ Archivo ZIP.ENC detectado correctamente");
                await procesarArchivoZipEnc(contenidoArchivo);
            } 
            // Otros tipos de archivos
            else {
                log(`‚ö†Ô∏è Formato de archivo no reconocido: ${archivo.name}. Se esperaba un archivo .zip.enc`);
                return null;
            }
        } catch (error) {
            log(`‚ùå Error al leer el archivo: ${error.message}`);
            console.error("Error detallado:", error);
        }
    }

    // Leer contenido del archivo como ArrayBuffer
    function leerArchivo(archivo) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            
            reader.onload = (event) => {
                resolve(event.target.result);
            };
            
            reader.onerror = (error) => {
                reject(error);
            };
            
            reader.readAsArrayBuffer(archivo);
        });
    }

    // Procesar archivo ZIP.ENC
    async function procesarArchivoZipEnc(contenidoArchivo) {
        log("üîç Procesando archivo ZIP encriptado...");
        
        try {
            // Mostrar m√°s informaci√≥n sobre el contenido para debug
            log(`üìä Tama√±o del archivo: ${contenidoArchivo.byteLength} bytes`);
            
            // Descomprimir el ZIP para obtener los archivos internos
            const zip = new JSZip();
            
            try {
                const zipContent = await zip.loadAsync(contenidoArchivo);
                
                // Listar todos los archivos encontrados en el ZIP para debug
                const filesFound = Object.keys(zipContent.files);
                log(`üìÑ Archivos en el ZIP: ${filesFound.length > 0 ? filesFound.join(', ') : 'ninguno'}`);
                
                // Verificar si contiene los archivos esperados (datos.enc y metadata.json)
                if (zipContent.files['datos.enc'] && zipContent.files['metadata.json']) {
                    // Extraer los datos cifrados
                    contenidoCifrado = await zipContent.files['datos.enc'].async('uint8array');
                    log(`üì¶ Datos cifrados extra√≠dos: ${contenidoCifrado.length} bytes`);
                    
                    // Extraer y parsear los metadatos
                    const metadataText = await zipContent.files['metadata.json'].async('text');
                    log(`üìù Metadata extra√≠da: ${metadataText.substring(0, 100)}...`);
                    
                    try {
                        metadatosRegistro = JSON.parse(metadataText);
                        
                        log(`‚úÖ Archivo procesado correctamente. Metadatos obtenidos.`);
                        
                        // Preparar el objeto para el descifrado
                        registroElegido = {
                            datosCifrados: Array.from(contenidoCifrado),
                            iv: metadatosRegistro.iv,
                            salt: metadatosRegistro.salt,
                            nombreRegistro: metadatosRegistro.nombreRegistro || nombreRegistroElegido
                        };
                        
                        // En caso de que no est√© en los metadatos
                        if (!nombreRegistroElegido) {
                            nombreRegistroElegido = metadatosRegistro.nombreRegistro || "RegistroSinNombre";
                        }
                    } catch (jsonError) {
                        log(`‚ö†Ô∏è Error al parsear JSON de metadatos: ${jsonError.message}`);
                        // Intentamos una recuperaci√≥n alternativa
                        registroElegido = {
                            datosCifrados: Array.from(contenidoCifrado),
                            // Usar valores predeterminados si no podemos extraer los reales
                            iv: [], 
                            salt: []
                        };
                    }
                } else {
                    log("‚ùå El archivo ZIP no contiene los archivos esperados (datos.enc y metadata.json)");
                    
                    // Intento de recuperaci√≥n alternativa
                    if (Object.keys(zipContent.files).length > 0) {
                        const primerArchivo = Object.keys(zipContent.files)[0];
                        log(`‚ö° Intentando recuperaci√≥n con el primer archivo: ${primerArchivo}`);
                        
                        contenidoCifrado = await zipContent.files[primerArchivo].async('uint8array');
                        
                        // Crear estructura m√≠nima para intentar descifrado
                        registroElegido = {
                            datosCifrados: Array.from(contenidoCifrado),
                            iv: [], // Tendremos que adivinar estos valores
                            salt: [],
                            nombreRegistro: nombreRegistroElegido
                        };
                    }
                }
            } catch (zipError) {
                log(`‚ö†Ô∏è Error al descomprimir ZIP: ${zipError.message}`);
                
                // √öltimos recursos: tratar el archivo completo como datos cifrados
                log("‚ö° Intentando procesar el archivo completo como datos cifrados...");
                
                contenidoCifrado = new Uint8Array(contenidoArchivo);
                registroElegido = {
                    datosCifrados: Array.from(contenidoCifrado),
                    // Generar IV y salt vac√≠os o aleatorios para intentar la descarga
                    iv: Array.from(crypto.getRandomValues(new Uint8Array(12))),
                    salt: Array.from(crypto.getRandomValues(new Uint8Array(16))),
                    nombreRegistro: nombreRegistroElegido
                };
            }
        } catch (error) {
            log(`‚ùå Error general al procesar el archivo: ${error.message}`);
            console.error("Error detallado:", error);
        }
    }

    // Iniciar el ataque seg√∫n el modo seleccionado
    async function iniciarAtaque() {
        const modo = modoSelector.value;
        
        log(`‚ö° Iniciando ataque en modo: ${modo}`);
        
        // Crear instancia de seguridad
        const seguridad = new SeguridadRegistros();
        
        // Ejecutar ataque seg√∫n el modo seleccionado
        switch (modo) {
            case "basico":
                await ejecutarAtaqueBasico(seguridad);
                break;
            case "claveMaestra":
                await ejecutarAtaqueClaveMaestra(seguridad);
                break;
            case "avanzado":
                await ejecutarAtaqueAvanzado(seguridad);
                break;
            default:
                log("‚ö†Ô∏è Modo de ataque no reconocido.");
        }
    }

    // Ataque b√°sico: probar contrase√±as comunes
    async function ejecutarAtaqueBasico(seguridad) {
        log("üîì Ejecutando ataque b√°sico (contrase√±as comunes)...");
        
        let intentos = 0;
        
        for (const password of contrasenasComunes) {
            intentos++;
            log(`üîë Intento ${intentos}: Probando contrase√±a "${password}"`);
            
            try {
                const resultado = await seguridad.descifrarRegistro(registroElegido, password);
                
                if (resultado) {
                    log(`‚úÖ √âXITO: Contrase√±a encontrada: "${password}"`);
                    mostrarResultado(resultado, password);
                    return true;
                }
            } catch (error) {
                // Solo registrar el error en la consola para debug
                console.log(`Contrase√±a incorrecta: ${password}`);
            }
            
            // A√±adir peque√±o retraso entre intentos para no bloquear la UI
            await new Promise(resolve => setTimeout(resolve, 200));
        }
        
        log(`‚ùå Ataque b√°sico fallido. Se probaron ${intentos} contrase√±as comunes.`);
        return false;
    }

    // Ataque usando la clave maestra del sessionStorage
    async function ejecutarAtaqueClaveMaestra(seguridad) {
        log("üîê Ejecutando ataque de clave maestra...");
        
        const claveMaestra = sessionStorage.getItem("claveMaestraTemporal");
        
        if (!claveMaestra) {
            log("‚ö†Ô∏è No se encontr√≥ ninguna clave maestra en el sessionStorage.");
            return false;
        }
        
        log(`üîë Clave maestra encontrada en sessionStorage: "${maskPassword(claveMaestra)}"`);
        
        // Crear nueva instancia con la clave maestra encontrada
        const seguridadConClave = new SeguridadRegistros(claveMaestra);
        
        // Buscar la clave del registro en localStorage
        const clavesRegistros = JSON.parse(localStorage.getItem('clavesRegistros')) || [];
        const claveRegistroInfo = clavesRegistros.find(cr => cr.nombreRegistro === nombreRegistroElegido);
        
        if (!claveRegistroInfo) {
            log(`‚ö†Ô∏è No se encontr√≥ informaci√≥n de clave para el registro: ${nombreRegistroElegido}`);
            return false;
        }
        
        try {
            log("üîì Intentando descifrar la clave del registro con la clave maestra...");
            
            // Descifrar la contrase√±a del registro usando la clave maestra
            const password = await seguridadConClave.descifrarConClaveMaestra(claveRegistroInfo.clave);
            
            log("üîë Contrase√±a del registro descifrada correctamente.");
            
            // Usar la contrase√±a para descifrar el registro
            const resultado = await seguridadConClave.descifrarRegistro(registroElegido, password);
            
            log("‚úÖ √âXITO: Registro descifrado correctamente mediante clave maestra.");
            mostrarResultado(resultado, password);
            return true;
        } catch (error) {
            log(`‚ùå Error al descifrar con clave maestra: ${error.message}`);
            console.error("Error detallado:", error);
            return false;
        }
    }

    // Ataque avanzado: combinaci√≥n de clave maestra y fuerza bruta
    async function ejecutarAtaqueAvanzado(seguridad) {
        log("‚ö° Ejecutando ataque avanzado...");
        
        // Primero intentar con clave maestra
        const exito = await ejecutarAtaqueClaveMaestra(seguridad);
        
        if (exito) {
            return true;
        }
        
        log("‚Ü™Ô∏è Ataque con clave maestra fall√≥, pasando a ataque de fuerza bruta avanzado...");
        
        // Si no funciona, intentar fuerza bruta con un conjunto m√°s amplio
        // Generar combinaciones de caracteres m√°s complejas
        return await ejecutarFuerzaBrutaAvanzada(seguridad);
    }

    // Fuerza bruta avanzada para el ataque avanzado
    async function ejecutarFuerzaBrutaAvanzada(seguridad) {
        const caracteresBasicos = "abcdefghijklmnopqrstuvwxyz0123456789";
        const caracteresAvanzados = caracteresBasicos + "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()_+";
        
        // Probar primero con contrase√±as comunes modificadas
        const contrasenasMod = generarVariacionesContrasenas(contrasenasComunes);
        
        log(`üîç Probando ${contrasenasMod.length} variaciones de contrase√±as comunes...`);
        
        for (const password of contrasenasMod) {
            try {
                const resultado = await seguridad.descifrarRegistro(registroElegido, password);
                
                if (resultado) {
                    log(`‚úÖ √âXITO: Contrase√±a encontrada: "${password}"`);
                    mostrarResultado(resultado, password);
                    return true;
                }
            } catch (error) {
                // Ignorar errores
            }
            
            // A√±adir peque√±o retraso entre intentos
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        log("‚Ü™Ô∏è No se encontr√≥ la contrase√±a en las variaciones comunes.");
        
        // Generar contrase√±as aleatoriamente (limitado a un n√∫mero razonable de intentos)
        const maxIntentos = 1000;
        log(`üîÑ Iniciando fuerza bruta aleatoria (m√°ximo ${maxIntentos} intentos)...`);
        
        for (let i = 0; i < maxIntentos; i++) {
            // Alternar entre longitudes de 4 a 8 caracteres
            const longitud = 4 + Math.floor(Math.random() * 5);
            const password = generarClaveAleatoria(longitud, caracteresAvanzados);
            
            if (i % 100 === 0) {
                log(`üîÑ Progreso: ${i}/${maxIntentos} intentos...`);
            }
            
            try {
                const resultado = await seguridad.descifrarRegistro(registroElegido, password);
                
                if (resultado) {
                    log(`‚úÖ √âXITO: Contrase√±a encontrada: "${password}" (intento ${i+1})`);
                    mostrarResultado(resultado, password);
                    return true;
                }
            } catch (error) {
                // Ignorar errores
            }
        }
        
        log(`‚ùå Ataque avanzado fallido despu√©s de ${maxIntentos} intentos.`);
        return false;
    }

    // Generar variaciones de contrase√±as comunes
    function generarVariacionesContrasenas(contrasenas) {
        const variaciones = [];
        
        // Agregar las contrase√±as originales
        variaciones.push(...contrasenas);
        
        // Agregar variaciones con may√∫sculas al inicio
        contrasenas.forEach(pass => {
            if (pass.length > 0) {
                variaciones.push(pass[0].toUpperCase() + pass.slice(1));
            }
        });
        
        // Agregar n√∫meros al final
        contrasenas.forEach(pass => {
            for (let i = 0; i < 10; i++) {
                variaciones.push(pass + i);
            }
        });
        
        // Agregar s√≠mbolos comunes al final
        const simbolos = ['!', '@', '#', '$', '%', '&', '*'];
        contrasenas.forEach(pass => {
            simbolos.forEach(simbolo => {
                variaciones.push(pass + simbolo);
            });
        });
        
        return variaciones;
    }

    // Generar clave aleatoria para fuerza bruta
    function generarClaveAleatoria(longitud, caracteres) {
        let clave = "";
        for (let i = 0; i < longitud; i++) {
            clave += caracteres.charAt(Math.floor(Math.random() * caracteres.length));
        }
        return clave;
    }

    // Mostrar resultado del descifrado
    function mostrarResultado(resultado, password) {
        log(`üîê Contrase√±a utilizada: "${password}"`);
        log("üìã Datos descifrados correctamente:");
        
        visorJson.textContent = JSON.stringify(resultado, null, 2);
        
        // Guardar en localStorage para fines educativos
        guardarResultado(resultado, password);
    }

    // Guardar resultado del ataque
    function guardarResultado(resultado, password) {
        // Crear una copia del resultado y agregar la contrase√±a usada
        const resultadoConPass = { ...resultado, _passwordUsada: password };
        
        // Guardar en localStorage el registro descifrado
        const resultadosGuardados = JSON.parse(localStorage.getItem('resultadosAtaques') || '[]');
        resultadosGuardados.push(resultadoConPass);
        localStorage.setItem('resultadosAtaques', JSON.stringify(resultadosGuardados));
        
        log("üíæ Resultado guardado en localStorage['resultadosAtaques']");
    }

    // Ocultar parte de la contrase√±a para mostrarla en logs
    function maskPassword(password) {
        if (!password || password.length <= 3) return "***";
        return password.substring(0, 2) + "*".repeat(password.length - 3) + password.substring(password.length - 1);
    }

    // Funciones de logging
    function log(mensaje) {
        const timestamp = new Date().toLocaleTimeString();
        visorLog.textContent += `[${timestamp}] ${mensaje}\n`;
        visorLog.scrollTop = visorLog.scrollHeight; // Auto-scroll
        console.log(mensaje);
    }

    function limpiarVisor() {
        visorLog.textContent = "";
        visorJson.textContent = "";
    }

    // Iniciar script
    init();
});